name: Manual Predictions Trigger - ENHANCED

on:
  workflow_dispatch:
    inputs:
      symbols_to_predict:
        description: 'Symbols (comma-separated, or leave empty for default)'
        required: false
        default: 'BTC/USDT,ETH/USDT,SOL/USDT,EURUSD,GBPUSD'

env:
  API_BASE_URL: ${{ secrets.VERCEL_DEPLOYMENT_URL || 'https://trading-models.vercel.app' }}

jobs:
  # ============================================================================
  # STEP 1: Verify MongoDB Access (CRITICAL FIX)
  # ============================================================================
  verify-mongodb:
    name: Verify MongoDB Connection
    runs-on: ubuntu-latest
    
    steps:
      - name: Check MongoDB Atlas Connectivity
        run: |
          echo "‚è≥ Testing MongoDB Atlas connection..."
          
          # Test if API can reach MongoDB
          RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/store-prediction?health=true" \
            --max-time 10 -w "\nHTTP_CODE:%{http_code}")
          
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå FATAL: Cannot connect to MongoDB!"
            echo ""
            echo "TROUBLESHOOTING STEPS:"
            echo "1. Check MongoDB Atlas Network Access ‚Üí IP Access List"
            echo "2. Add IP: 0.0.0.0/0 (Allow from anywhere) OR"
            echo "3. Use dynamic IP whitelisting (see documentation)"
            echo ""
            echo "Current error response:"
            echo "$BODY"
            exit 1
          fi
          
          echo "‚úÖ MongoDB connection verified"

  # ============================================================================
  # STEP 2: NEW - Warm Up Models BEFORE Predictions
  # ============================================================================
  warm-up-models:
    name: Warm Up ML Models
    runs-on: ubuntu-latest
    needs: verify-mongodb
    
    steps:
      - name: Warm up Vercel functions
        run: |
          echo "üî• Warming up ML models and functions..."
          
          # Call warm-up endpoint
          RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/warm-up" \
            --max-time 30 -w "\nHTTP_CODE:%{http_code}")
          
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Models warmed up successfully"
            
            # Try to parse warmup details if JSON response
            if echo "$BODY" | jq empty 2>/dev/null; then
              WARMUP_TIME=$(echo "$BODY" | jq -r '.warmupTime // "N/A"')
              MODELS_COUNT=$(echo "$BODY" | jq -r '.modelsWarmed // "N/A"')
              echo "   Warmup time: ${WARMUP_TIME}ms"
              echo "   Models warmed: $MODELS_COUNT"
            fi
          else
            echo "‚ö†Ô∏è Warmup returned HTTP $HTTP_CODE (continuing anyway)"
            echo "   This may result in slower first predictions"
          fi
          
          # Wait for function to stay warm and models to be fully loaded
          echo "‚è≥ Allowing models to stabilize..."
          sleep 15

  # ============================================================================
  # STEP 3: Generate Predictions (Now using warm instances)
  # ============================================================================
  manual-predictions:
    name: Generate Predictions (Manual Trigger)
    runs-on: ubuntu-latest
    needs: [verify-mongodb, warm-up-models]  # ‚≠ê Wait for both MongoDB and warmup
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Display configuration
        run: |
          echo "üéØ API Base URL: ${{ env.API_BASE_URL }}"
          echo "üìä Symbols: ${{ github.event.inputs.symbols_to_predict || 'BTC/USDT,ETH/USDT,SOL/USDT,EURUSD,GBPUSD' }}"
          echo "üî• Models are pre-warmed for faster predictions"
      
      # ======================================================================
      # Predict: BTC/USDT (WITH RETRY LOGIC)
      # ======================================================================
      - name: Predict BTC/USDT
        continue-on-error: true
        id: predict_btc
        run: |
          echo "ü™ô Processing BTC/USDT..."
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "  üîÑ Retry attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
              sleep $((RETRY_COUNT * 5))  # Exponential backoff
            fi
            
            # Fetch market data with enhanced error handling
            echo "  üì• Fetching market data..."
            FETCH_RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/fetch-data?symbol=BTC%2FUSDT" \
              --max-time 30 -w "\nHTTP_CODE:%{http_code}")
            
            FETCH_HTTP=$(echo "$FETCH_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            FETCH_BODY=$(echo "$FETCH_RESPONSE" | sed '/HTTP_CODE:/d')
            
            # Check HTTP status
            if [ "$FETCH_HTTP" != "200" ]; then
              echo "  ‚ùå Fetch failed (HTTP $FETCH_HTTP)"
              echo "  Response: $(echo "$FETCH_BODY" | head -c 300)"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Validate JSON
            if ! echo "$FETCH_BODY" | jq empty 2>/dev/null; then
              echo "  ‚ùå Invalid JSON response"
              echo "  Response: $(echo "$FETCH_BODY" | head -c 300)"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Check success flag
            FETCH_SUCCESS=$(echo "$FETCH_BODY" | jq -r '.success // false')
            if [ "$FETCH_SUCCESS" != "true" ]; then
              echo "  ‚ùå API returned success=false"
              ERROR=$(echo "$FETCH_BODY" | jq -r '.error // "Unknown"')
              echo "  Error: $ERROR"
              
              # If validation error, don't retry (won't fix itself)
              if echo "$ERROR" | grep -qi "validation"; then
                echo "  ‚ö†Ô∏è Validation error detected - skipping retries"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            echo "  ‚úÖ Data fetched successfully"
            
            # Extract data payload
            DATA_PAYLOAD=$(echo "$FETCH_BODY" | jq -c '.data // {}')
            
            if [ "$DATA_PAYLOAD" = "{}" ] || [ "$DATA_PAYLOAD" = "null" ]; then
              echo "  ‚ùå No data in response"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Run prediction (should be faster due to warmup)
            echo "  ü§ñ Running prediction (using pre-warmed models)..."
            PRED_RESPONSE=$(curl -s -X POST "${{ env.API_BASE_URL }}/api/predict-crypto" \
              -H "Content-Type: application/json" \
              --max-time 45 \
              -w "\nHTTP_CODE:%{http_code}" \
              -d "{\"symbol\":\"BTC/USDT\",\"data\":$DATA_PAYLOAD}")
            
            PRED_HTTP=$(echo "$PRED_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            PRED_BODY=$(echo "$PRED_RESPONSE" | sed '/HTTP_CODE:/d')
            
            if [ "$PRED_HTTP" != "200" ]; then
              echo "  ‚ùå Prediction failed (HTTP $PRED_HTTP)"
              echo "  Response: $(echo "$PRED_BODY" | head -c 300)"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Validate prediction JSON
            if ! echo "$PRED_BODY" | jq empty 2>/dev/null; then
              echo "  ‚ùå Invalid prediction JSON"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Check prediction success
            PRED_SUCCESS=$(echo "$PRED_BODY" | jq -r '.success // false')
            if [ "$PRED_SUCCESS" != "true" ]; then
              echo "  ‚ùå Prediction API returned success=false"
              ERROR=$(echo "$PRED_BODY" | jq -r '.error // "Unknown"')
              echo "  Error: $ERROR"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Extract results
            PRED_CLASS=$(echo "$PRED_BODY" | jq -r '.class // "UNKNOWN"')
            PRED_CONF=$(echo "$PRED_BODY" | jq -r '.confidence // 0')
            STORED=$(echo "$PRED_BODY" | jq -r '.stored // false')
            DURATION=$(echo "$PRED_BODY" | jq -r '.processingTime // "N/A"')
            
            echo "  ‚úÖ Prediction: $PRED_CLASS (Confidence: $(echo "$PRED_CONF * 100" | bc -l | cut -d. -f1)%)"
            echo "  üíæ Stored: $STORED"
            echo "  ‚è±Ô∏è Processing time: ${DURATION}ms"
            
            SUCCESS=true
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "  ‚ùå Failed after $MAX_RETRIES attempts"
            exit 1
          fi
      
      # ======================================================================
      # Predict: ETH/USDT (WITH RETRY LOGIC)
      # ======================================================================
      - name: Predict ETH/USDT
        continue-on-error: true
        id: predict_eth
        run: |
          echo "ü™ô Processing ETH/USDT..."
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "  üîÑ Retry attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
              sleep $((RETRY_COUNT * 5))
            fi
            
            echo "  üì• Fetching market data..."
            FETCH_RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/fetch-data?symbol=ETH%2FUSDT" \
              --max-time 30 -w "\nHTTP_CODE:%{http_code}")
            
            FETCH_HTTP=$(echo "$FETCH_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            FETCH_BODY=$(echo "$FETCH_RESPONSE" | sed '/HTTP_CODE:/d')
            
            if [ "$FETCH_HTTP" != "200" ]; then
              echo "  ‚ùå Fetch failed (HTTP $FETCH_HTTP)"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            if ! echo "$FETCH_BODY" | jq empty 2>/dev/null; then
              echo "  ‚ùå Invalid JSON response"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            FETCH_SUCCESS=$(echo "$FETCH_BODY" | jq -r '.success // false')
            if [ "$FETCH_SUCCESS" != "true" ]; then
              ERROR=$(echo "$FETCH_BODY" | jq -r '.error // "Unknown"')
              echo "  ‚ùå API error: $ERROR"
              
              if echo "$ERROR" | grep -qi "validation"; then
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            DATA_PAYLOAD=$(echo "$FETCH_BODY" | jq -c '.data // {}')
            
            if [ "$DATA_PAYLOAD" = "{}" ] || [ "$DATA_PAYLOAD" = "null" ]; then
              echo "  ‚ùå No data in response"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            echo "  ü§ñ Running prediction (using pre-warmed models)..."
            PRED_RESPONSE=$(curl -s -X POST "${{ env.API_BASE_URL }}/api/predict-crypto" \
              -H "Content-Type: application/json" \
              --max-time 45 \
              -w "\nHTTP_CODE:%{http_code}" \
              -d "{\"symbol\":\"ETH/USDT\",\"data\":$DATA_PAYLOAD}")
            
            PRED_HTTP=$(echo "$PRED_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            PRED_BODY=$(echo "$PRED_RESPONSE" | sed '/HTTP_CODE:/d')
            
            if [ "$PRED_HTTP" != "200" ] || ! echo "$PRED_BODY" | jq empty 2>/dev/null; then
              echo "  ‚ùå Prediction failed"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            PRED_SUCCESS=$(echo "$PRED_BODY" | jq -r '.success // false')
            if [ "$PRED_SUCCESS" != "true" ]; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            PRED_CLASS=$(echo "$PRED_BODY" | jq -r '.class // "UNKNOWN"')
            PRED_CONF=$(echo "$PRED_BODY" | jq -r '.confidence // 0')
            DURATION=$(echo "$PRED_BODY" | jq -r '.processingTime // "N/A"')
            
            echo "  ‚úÖ Prediction: $PRED_CLASS (Confidence: $(echo "$PRED_CONF * 100" | bc -l | cut -d. -f1)%)"
            echo "  ‚è±Ô∏è Processing time: ${DURATION}ms"
            
            SUCCESS=true
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "  ‚ùå Failed after $MAX_RETRIES attempts"
            exit 1
          fi
      
      # ======================================================================
      # Predict: SOL/USDT (WITH RETRY LOGIC)
      # ======================================================================
      - name: Predict SOL/USDT
        continue-on-error: true
        id: predict_sol
        run: |
          echo "ü™ô Processing SOL/USDT..."
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "  üîÑ Retry attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
              sleep $((RETRY_COUNT * 5))
            fi
            
            echo "  üì• Fetching market data..."
            FETCH_RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/fetch-data?symbol=SOL%2FUSDT" \
              --max-time 30 -w "\nHTTP_CODE:%{http_code}")
            
            FETCH_HTTP=$(echo "$FETCH_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            FETCH_BODY=$(echo "$FETCH_RESPONSE" | sed '/HTTP_CODE:/d')
            
            if [ "$FETCH_HTTP" != "200" ] || ! echo "$FETCH_BODY" | jq empty 2>/dev/null; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            FETCH_SUCCESS=$(echo "$FETCH_BODY" | jq -r '.success // false')
            if [ "$FETCH_SUCCESS" != "true" ]; then
              ERROR=$(echo "$FETCH_BODY" | jq -r '.error // "Unknown"')
              if echo "$ERROR" | grep -qi "validation"; then
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            DATA_PAYLOAD=$(echo "$FETCH_BODY" | jq -c '.data // {}')
            if [ "$DATA_PAYLOAD" = "{}" ] || [ "$DATA_PAYLOAD" = "null" ]; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            echo "  ü§ñ Running prediction (using pre-warmed models)..."
            PRED_RESPONSE=$(curl -s -X POST "${{ env.API_BASE_URL }}/api/predict-crypto" \
              -H "Content-Type: application/json" \
              --max-time 45 \
              -w "\nHTTP_CODE:%{http_code}" \
              -d "{\"symbol\":\"SOL/USDT\",\"data\":$DATA_PAYLOAD}")
            
            PRED_HTTP=$(echo "$PRED_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
            PRED_BODY=$(echo "$PRED_RESPONSE" | sed '/HTTP_CODE:/d')
            
            if [ "$PRED_HTTP" != "200" ] || ! echo "$PRED_BODY" | jq empty 2>/dev/null; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            PRED_SUCCESS=$(echo "$PRED_BODY" | jq -r '.success // false')
            if [ "$PRED_SUCCESS" != "true" ]; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            PRED_CLASS=$(echo "$PRED_BODY" | jq -r '.class // "UNKNOWN"')
            PRED_CONF=$(echo "$PRED_BODY" | jq -r '.confidence // 0')
            DURATION=$(echo "$PRED_BODY" | jq -r '.processingTime // "N/A"')
            
            echo "  ‚úÖ Prediction: $PRED_CLASS (Confidence: $(echo "$PRED_CONF * 100" | bc -l | cut -d. -f1)%)"
            echo "  ‚è±Ô∏è Processing time: ${DURATION}ms"
            
            SUCCESS=true
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "  ‚ùå Failed after $MAX_RETRIES attempts"
            exit 1
          fi
      
      # ======================================================================
      # Storage Verification
      # ======================================================================
      - name: Verify stored predictions
        continue-on-error: true
        run: |
          echo "üîç Verifying predictions in database..."
          
          RESPONSE=$(curl -s "${{ env.API_BASE_URL }}/api/get-predictions?limit=5" \
            --max-time 10 -w "\nHTTP_CODE:%{http_code}")
          
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
          
          if [ "$HTTP_CODE" = "200" ]; then
            if echo "$BODY" | jq empty 2>/dev/null; then
              TOTAL=$(echo "$BODY" | jq -r '.pagination.total_count // 0')
              RETURNED=$(echo "$BODY" | jq -r '.pagination.returned_count // 0')
              
              echo "‚úÖ Database query successful"
              echo "   Total predictions: $TOTAL"
              echo "   Retrieved: $RETURNED"
              
              if [ "$RETURNED" -gt 0 ]; then
                echo ""
                echo "Latest prediction:"
                echo "$BODY" | jq -r '.data[0] | "  Symbol: \(.symbol // .pair)\n  Class: \(.class)\n  Confidence: \(.confidence)\n  Time: \(.timestamp)"'
              fi
            else
              echo "‚ö†Ô∏è Invalid JSON response"
            fi
          else
            echo "‚ö†Ô∏è HTTP $HTTP_CODE"
          fi
      
      - name: Summary
        if: always()
        run: |
          echo ""
          echo "========================================================================"
          echo "‚úÖ MANUAL PREDICTIONS COMPLETE"
          echo "========================================================================"
          echo ""
          echo "üåê Dashboard: ${{ env.API_BASE_URL }}"
          echo "üî• Used pre-warmed models for faster predictions"
          echo ""
          echo "üîÑ Refresh your dashboard to see new predictions"
          echo ""